#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import math

from PyQt4.QtGui import *
from PyQt4.QtCore import *
from figdexGUI import Ui_DisplayWindow


class MyMainWindow(QMainWindow):
    def __init__(self):
        QMainWindow.__init__(self)
        # 'Ui_MyMainWindow' is the class, that was generated by uic, 
        # naming convention is: 'Ui_' plus the name of root widget in designer
        self.ui = Ui_DisplayWindow()
        self.ui.setupUi(self)
        
    @pyqtSlot()
    def btnStartClicked(self):
        self.ui.lstResults.clear()
        lst = run(self.ui.boxNb.text())
        for i in range(0, len(lst)):
          strResult = " ".join(str(e) for e in lst[i])
          self.ui.lstResults.addItem(strResult)
          
          
    def paintEvent(self, event):
        painter = QPainter(self)
        lstRect = self.ui.lstResults.rect()
        wndRect = self.rect()

        nbPoints = self.ui.boxNb.text()

        # définition de notre zone de dessin : à droite des listes/boutons et à 10 pixels de marge de chaque côté
        drawingArea = QRect(lstRect.right() + 20, 10,
                          wndRect.width() - lstRect.width() - lstRect.x() - 30,
                          wndRect.height() - 20)

        # on recadre la zone de dessin pour former un carré
        if (drawingArea.width() > drawingArea.height()):
            drawingArea.setWidth(drawingArea.height())
        else:
            drawingArea.setHeight(drawingArea.width())

        print "Drawing circle from", drawingArea.x(), "/", drawingArea.y(), "to", drawingArea.right(), "/", drawingArea.bottom()
        painter.drawEllipse(drawingArea)

        selection = self.ui.lstResults.selectedItems()
        if (selection == []):
          print "Selection vide"
        else:
          x = drawingArea.left() + drawingArea.width()/2
          y = drawingArea.top()
          
          points = selection[0].text().split(" ")

          for i in range(1, len(points)):
              # calcul de l'angle par rapport à la verticale
              angle = ((360 / len(points)) * (int(points[i]) - 1))

              # conversion par rapport à l'horizontale
              angle = (angle - 90) * -1

              # conversion en radians (pour les fonctions cos() et sin() qui ne gèrent pas les degrés
              angle = angle * math.pi / 180

              # on va calculer la position du point destination par rapport au centre du cercle
              # avec x et y définit à partir de la position centrale
              # sin(angle) = (y) / rayon => y = rayon * sin(angle)
              # cos(angle) = (x) / rayon => x = rayon * cos(angle)
              sinus = math.sin(angle)
              cosinus = math.cos(angle)

              destX = drawingArea.x() + drawingArea.width()/2 + (cosinus * (drawingArea.width()/2))
              destY = drawingArea.y() + drawingArea.height()/2 - (sinus * drawingArea.height()/2)

              print "Angle = ", angle, " cos = ", cosinus, " sin = ", sinus
              print "Drawing line from ", x, "/", y, "to", destX, "/", destY
              painter.drawLine(x, y, destX, destY)

              x = destX
              y = destY

          print "Drawing (final) line from", x, "/", y,  "to", drawingArea.x() + drawingArea.width()/2, "/", drawingArea.y() + 10
          painter.drawLine(x, y, drawingArea.x() + drawingArea.width()/2, drawingArea.y())
          

def test(liste, resultats):
#  print "test", liste, resultats
  if (liste in resultats):
    return True
  # inversion des points apres le premier
  # Ceci est necessaire dans la comparaison, pour que le programme determine
  # qu'une figure peut etre dessinee dans un sens ou dans l'autre.
  # Ex : 1234 = 1432
  rev=list(liste[1:])
  rev.reverse()
  rev.insert(0, liste[0])
  if (rev in resultats):
    return True
    
  # cherche le point 1 pour commencer le dessin. Verifie qu'en partant de
  # celui-ci, on ne retrouve pas des figures existantes
  i=liste.index(1)
  if (i > 0):
    newList=list(liste[i:])
    newList = newList + list(liste[:i])
    if (test(newList, resultats)):
      return True
  return False

def calcul(listPrefix, remainingPoints, resultats):
#  print "calcul", listPrefix, remainingPoints, resultats
  if (len(remainingPoints) == 1):
    # terminus
    liste = list(listPrefix)
    liste.append(remainingPoints[0])
    if (test(liste, resultats) == False):
#      print "Ajout de", liste
      resultats.append(liste)
#    else:
#      print "Skip", liste
  else:
    for i in range(0, len(remainingPoints)):
      liste = list(listPrefix)
      liste.append(remainingPoints[i])
      fin = list(remainingPoints)
      del fin[i]
      calcul(liste, fin, resultats)
#      print "loop:", i, listPrefix, remainingPoints, resultats
  return resultats

def run(nb):
  remaining=[]
  for i in range(0, int(nb)):
    remaining.append(i+1)

  return calcul ([], remaining, [])


if __name__ == "__main__":
  if (len(sys.argv) < 2):
    print "Usage:"
    print "figex <nb points>"
    print "=> lance le calcul et affiche le resultat en ligne de commande"
    print ""
    print "figdex --gui"
    print "=> lance la version graphique"
    sys.exit(0)

  if (sys.argv[1] == "--gui"):
    print "Version GUI"
    app=QApplication(sys.argv)
    
    #fin de l'application lorsque toutes les fenêtres sont fermées
    app.connect(app,SIGNAL("lastWindowClosed()"),app,SLOT("quit()"))
    
    window = MyMainWindow()
    
    app.connect(window.ui.btnStart, SIGNAL("clicked()"), window, SLOT("btnStartClicked()"))
    app.connect(window.ui.lstResults, SIGNAL("itemSelectionChanged()"), window, SLOT("repaint()"))
    
    window.show()
    
    app.exec_()
  else:
    print "Calcul pour " + sys.argv[1] + " points"

    res = run(sys.argv[1])

    print "Resultats:"
    print res

